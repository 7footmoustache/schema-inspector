{
  "name": "schema-inspector",
  "version": "1.3.1",
  "main": "./lib/schema-inspector.js",
  "dependencies": {
    "async": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# Schema-Inspector\n\nSchema-Inspector is powerful tool to validation or sanitize javascript object.\nIt is disigned to work both client-side and server-side. Although originally\ndesigned for use with [node.js](http://nodejs.org), it can also be used directly\nin the browser.\n\nSchema-Inspector has to be very scalable, and allow asynchronous and synchronous\ncalls.\n\n## Quick Examples\n\n### Synchronous call\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'string', eq: 'ipsum' },\n\t\t\tdolor: {\n\t\t\t\ttype: 'array',\n\t\t\t\titems: { type: 'number' }\n\t\t\t}\n\t\t}\n\t};\n\n\tvar candidate = {\n\t\tlorem: 'not_ipsum',\n\t\tdolor: [ 12, 34, 'ERROR', 45, 'INVALID' ]\n\t};\n\tvar result = SchemaInspector.validate(schema, candidate); // Candidate is not valid\n\tconsole.log(result.format());\n\t/*\n\t\tProperty @.lorem: must be equal to \"ipsum\", but is equal to \"not_ipsum\"\n\t\tProperty @.dolor[2]: must be number, but is string\n\t\tProperty @.dolor[4]: must be number, but is string\n\t*/\n```\n\n### Asynchronous call\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = { ...\t};\n\n\tvar candidate = { ... };\n\n\tSchemaInspector.validate(schema, candidate, function (err, result) {\n\t\tconsole.log(result.format());\n\t\t/*\n\t\t\tProperty @.lorem: must be equal to \"ipsum\", but is equal to \"not_ipsum\"\n\t\t\tProperty @.dolor[2]: must be number, but is string\n\t\t\tProperty @.dolor[4]: must be number, but is string\n\t\t*/\n\t});\n```\n\n### Custom fields\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\titems: { type: 'number', $divisibleBy: 5 }\n\t};\n\n\tvar custom = {\n\t\tdivisibleBy: function (schema, candidate) {\n\t\t\tvar dvb = schema.$divisibleBy;16\n\t\t\tif (cndidate % dvb !== 0) {\n\t\t\t\tthis.report('must be divisible by ' + dvb);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar candidate = [ 5, 10, 15, 16 ];\n\tsi.validate(schema, candidate, custom); // Invalid: \"@[3] must be divisible by 5\"\n```\n\n## In the browser\n\n```html\n<script type=\"text/javascript\" src=\"async.js\"></script>\n<script type=\"text/javascript\" src=\"schema-inspetor.js\"></script>\n\n<script type=\"text/javascript\">\n\n\tSchemaInspector.validate(schema, candidate, function (err, result) {\n\t\talert(result.format());\n\t});\n\n</script>\n```\n\n## Documentation\n\n### Validation\n\n* [type](#v_type)\n* [optional](#v_optional)\n* [pattern](#v_pattern)\n* [minLength, maxLength, exactLength](#v_length)\n* [lt, lte, gt, gte, eq, ne](#v_comparators)\n* [someKeys](#v_someKeys)\n* [strict](#v_strict)\n* [exec](#v_exec)\n* [properties](#v_properties)\n* [items](#v_items)\n* [alias](#v_alias)\n* [error](#v_error)\n\n### Sanitization\n\n* [type](#s_type)\n* [def](#s_def)\n* [optional](#s_optional)\n* [rules](#s_rules)\n* [min, min](#s_comparators)\n* [minLength, maxLength](#s_length)\n* [exec](#s_exec)\n* [properties](#s_properties)\n* [items](#s_items)\n\n### Custom fields\n* [punctual use](#cf_punctual)\n* [extension](#cf_extension)\n* [context](#cf_context)\n\n### Asynchronous call\n* [How to](#a_howTo)\n\n## Validation\n\n<a name=\"v_type\" />\n### type\n\n* **type**: string, array of string.\n* **usable on**: any.\n* **possible values**\n\t* `string`\n\t* `number`\n\t* `integer`\n\t* `boolean`\n\t* `null`\n\t* `date` (constructor === Date)\n\t* `object` (constructor === Object)\n\t* `array` (constructor === Array)\n\t* `any` (it can be anything)\n\nAllow to check property type. If the given value is incorrect, then type is not\nchecked.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: {  type: 'number' },\n\t\t\tipsum: { type: 'any' },\n\t\t\tdolor: { type: ['number' 'string', 'null'] }\n\t\t}\n\t};\n\n\tvar c1 = {\n\t\tlorem: 12,\n\t\tipsum: 'sit amet',\n\t\tdolor: 23\n\t};\n\tvar c2 = {\n\t\tlorem: 12,\n\t\tipsum: 34,\n\t\tdolor: 'sit amet'\n\t};\n\tvar c3 = {\n\t\tlorem: 12,\n\t\tipsum: [ 'sit amet' ],\n\t\tdolor: null\n\t};\n\tvar c4 = {\n\t\tlorem: '12',\n\t\tipsum: 'sit amet',\n\t\tdolor: new Date()\n\t};\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Valid\n\tsi.validate(schema, c3); // Valid\n\tsi.validate(schema, c4); // Invalid: @.lorem must be a number, @dolor must be a number, a string or null\n\n```\n\n---------------------------------------\n\n<a name=\"v_optional\" />\n### optional\n\n* **type**: boolean.\n* **default**: false.\n* **usable on**: any.\n\nThis field indicates whether or not property has to exist.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema1 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'any', optional: true }\n\t\t}\n\t};\n\n\tvar schema2 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'any', optional: false } // default value\n\t\t}\n\t};\n\n\tvar c1 = { lorem: 'ipsum' };\n\tvar c2 = { };\n\n\tsi.validate(schema1, c1); // Valid\n\tsi.validate(schema1, c2); // Valid\n\tsi.validate(schema2, c1); // Valid\n\tsi.validate(schema2, c2); // Invalid: \"@.lorem\" is missing and not optional\n```\n\n---------------------------------------\n\n<a name=\"v_uniqueness\" />\n### uniqueness\n\n* **type**: boolean.\n* **default**: false.\n* **usable on**: array, string.\n\nIf true, then we ensure no element in candidate exists more than once.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\tuniqueness: true\n\t};\n\n\tvar c1 = [12, 23, 34, 45];\n\tvar c2 = [12, 23, 34, 12];\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid: 12 exists twice in @.\n```\n\n---------------------------------------\n\n<a name=\"v_pattern\" />\n### pattern\n\n* **type**: string, RegExp object, array of string and RegExp.\n* **usable on**: string.\n* Possible values as a string: `void`, `url`, `date-time`, `date`,\n`coolDateTime`, `time`, `color`, `email`, `numeric`, `integer`, `decimal`,\n`alpha`, `alphaNumeric`, `alphaDash`, `javascript`, `upperString`, `lowerString`.\n\nAsk Schema-Inspector to check whether or not a given matches provided patterns.\nWhen a pattern is a RegExp, it directly test the string with it. When it's a\nstring, it's an alias of a RegExp.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema1 = {\n\t\ttype: 'array',\n\t\titems: { type: 'string', pattern: /^[A-C]/ }\n\t};\n\n\tvar c1 = ['Alorem', 'Bipsum', 'Cdolor', 'DSit amet'];\n\n\tvar schema2 = {\n\t\ttype: 'array',\n\t\titems: { type: 'string', pattern: 'email' }\n\t};\n\n\tvar c2 = ['lorem@ipsum.com', 'dolor@sit.com', 'amet@consectetur'];\n\n\tsi.validate(schema1, c1); // Invalid: @[3] ('DSit amet') does not match /^[A-C]/\n\tsi.validate(schema2, c2); // Invalid: @[2] ('amet@consectetur') does not match \"email\" pattern.\n```\n\n---------------------------------------\n\n<a name=\"v_length\" />\n### minLength, maxLength, exactLength\n\n* **type**: integer.\n* **usable on**: array, string.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'string', minLength: 4, maxLength: 8 },\n\t\t\tipsum: { type: 'array', exactLength: 6 },\n\t\t}\n\t};\n\tvar c1 = {\n\t\tlorem: '12345',\n\t\tipsum: [1, 2, 3, 4, 5, 6]\n\t};\n\n\tvar c2 = {\n\t\tlorem: '123456789',\n\t\tipsum: [1, 2, 3, 4, 5]\n\t};\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid: @.lorem must have a length between 4 and 8 (here 9)\n\t// and @.ipsum must have a length of 6 (here 5)\n```\n\n---------------------------------------\n\n<a name=\"v_comparators\" />\n### lt, lte, gt, gte, eq, ne\n\n* **type**: number.\n* **usable on**: number.\n\nCheck whether comparison is true:\n\n* lt: `<`\n* lte: `<=`\n* gt: `>`\n* gte: `>=`\n* eq: `===`\n* ne: `!==`\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', gt: 0, lt: 5 }, // Between ]0; 5[\n\t\t\tipsum: { type: 'number', gte: 0, lte: 5 }, // Between [0; 5]\n\t\t\tdolor: { type: 'number', eq: [0, 3, 6, 9] }, // Equal to 0, 3, 6 or 9\n\t\t\tsit: { type: 'number', ne: [0, 3, 6, 9] } // Not equal to 0, 3, 6 nor 9\n\t\t}\n\t};\n\n\tvar c1 = { lorem: 3, ipsum: 0, dolor: 6, sit: 2 };\n\tvar c2 = { lorem: 0, ipsum: -1, dolor: 5, sit: 3 };\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid\n```\n\n---------------------------------------\n\n<a name=\"v_someKeys\" />\n### someKeys\n\n* **type**: array of string.\n* **usable on**: object.\n\nCheck whether one of the given keys exists in object (useful when they are\noptional).\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tsomeKeys: ['lorem', 'ipsum']\n\t\tproperties: {\n\t\t\tlorem: { type: 'any', optional: true },\n\t\t\tipsum: { type: 'any', optional: true },\n\t\t\tdolor: { type: 'any' }\n\t\t}\n\t};\n\n\tvar c1 = { lorem: 0, ipsum: 1, dolor: 2  };\n\tvar c2 = { lorem: 0, dolor: 2  };\n\tvar c3 = { dolor: 2  };\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Valid\n\tsi.validate(schema, c3); // Invalid: Neither @.lorem nor @.ipsum is in c3.\n```\n\n---------------------------------------\n\n<a name=\"v_strict\" />\n### strict\n\n* **type**: boolean.\n* **default**: false.\n* **usable on**: object.\n\nOnly key provided in field \"properties\" may exist in object.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tstrict: true,\n\t\tproperties: {\n\t\t\tlorem: { type: 'any' },\n\t\t\tipsum: { type: 'any' },\n\t\t\tdolor: { type: 'any' }\n\t\t}\n\t};\n\n\tvar c1 = { lorem: 0, ipsum: 1, dolor: 2  };\n\tvar c2 = { lorem: 0, ipsum: 1, dolor: 2, sit: 3  };\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid: @.sit should not exist.\n```\n\n---------------------------------------\n\n<a name=\"v_exec\" />\n### exec\n\n* **type**: function, array of function.\n* **usable on**: any.\n\nCustom checker =). \"exec\" functions take two three parameter\n(schema, post [, callback]). To report an error, use `this.report([message])`.\nVery useful to make some custom validation.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: {\n\t\t\t\ttype: 'number',\n\t\t\t\texec: function (schema, post) {\n\t\t\t\t\t// here scheme === schema.properties.lorem and post === @.lorem\n\t\t\t\t\tif (post === 3) {\n\t\t\t\t\t\t// As soon as `this.report()` is called, candidate is not valid.\n\t\t\t\t\t\tthis.report('must not equal 3 =('); // Ok...it's exactly like \"ne: 3\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar c1 = { lorem: 2 };\n\tvar c2 = { lorem: 3 };\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid: \"@.lorem must not equal 3 =(\".\n```\n\n---------------------------------------\n\n<a name=\"v_properties\" />\n### properties\n\n* **type**: object.\n* **usable on**: object.\n\nFor each property in the field \"properties\", whose value must be a schema,\nvalidation is called deeper in object.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: {\n\t\t\t\ttype: 'object',\n\t\t\t\tproperties: {\n\t\t\t\t\tipsum: {\n\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tdolor: { type: 'string' }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tconsectetur: { type: 'string' }\n\t\t}\n\t};\n\n\tvar c1 = {\n\t\tlorem: {\n\t\t\tipsum: {\n\t\t\t\tdolor: 'sit amet'\n\t\t\t}\n\t\t},\n\t\tconsectetur: 'adipiscing elit'\n\t};\n\tvar c2 = {\n\t\tlorem: {\n\t\t\tipsum: {\n\t\t\t\tdolor: 12\n\t\t\t}\n\t\t},\n\t\tconsectetur: 'adipiscing elit'\n\t};\n\n\tsi.validate(schema, c1); // Valid\n\tsi.validate(schema, c2); // Invalid: @.lorem.ipsum.dolor must be a string.\n```\n\n---------------------------------------\n\n<a name=\"v_items\" />\n### items\n\n* **type**: object, array of object.\n* **usable on**: array.\n\nAllow to apply schema validation for each element in an array. If it's an\nobject, then it's a schema which will be used for all the element. If it's an\narray of object, then it's an array of schema and each element in an array will\nbe checked with the schema which has the same position in the array.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema1 = {\n\t\ttype: 'array',\n\t\titems: { type: 'number'\t}\n\t};\n\n\tvar schema2 = {\n\t\ttype: 'array',\n\t\titems: [\n\t\t\t{ type: 'number'\t},\n\t\t\t{ type: 'number'\t},\n\t\t\t{ type: 'string'\t}\n\t\t]\n\t};\n\n\tvar c1 = [1, 2, 3];\n\tvar c2 = [1, 2, 'string!'];\n\n\n\tsi.validate(schema1, c1); // Valid\n\tsi.validate(schema1, c2); // Invalid: @[2] must be a number.\n\tsi.validate(schema2, c1); // Valid\n\tsi.validate(schema2, c2); // Invalid: @[2] must be a string.\n```\n\n---------------------------------------\n\n<a name=\"v_alias\" />\n### alias\n\n* **type**: string.\n* **usable on**: any.\n\nAllow to display a more explicit property name if an error is encounted.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema1 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\t_id: { type: 'string'}\n\t\t}\n\t};\n\n\tvar schema2 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\t_id: { alias: 'id', type: 'string'}\n\t\t}\n\t};\n\n\tvar c1 = { _id: 1234567890 };\n\n\tvar r1 = si.validate(schema1, c1);\n\tvar r2 = si.validate(schema2, c1);\n\tconsole.log(r1.format()); // Property @._id: must be string, but is number\n\tconsole.log(r2.format()); // Property id (@._id): must be string, but is number\n```\n\n---------------------------------------\n\n<a name=\"v_error\" />\n### error\n\n* **type**: string.\n* **usable on**: any.\n\nThis field contains a user sentence for displaying a more explicit message if\nan error is encounted.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema1 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\t_id: { type: 'string' }\n\t\t}\n\t};\n\n\tvar schema2 = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\t_id: { type: 'string', error: 'must be a valid ID.' }\n\t\t}\n\t};\n\n\tvar c1 = { _id: 1234567890 };\n\n\tvar r1 = SchemaInspector.validate(schema1, c1);\n\tvar r2 = SchemaInspector.validate(schema2, c1);\n\tconsole.log(r1.format()); // Property @._id: must be string, but is number.\n\tconsole.log(r2.format()); // Property @._id: must be a valid ID.\n```\n\n## Sanitization\n\n<a name=\"s_type\" />\n### type\n\n* **type**: string.\n* **usable on**: any.\n* **possible values**\n\t* `number`\n\t* `integer`\n\t* `string`\n\t* `boolean`\n\t* `date` (constructor === Date)\n\t* `object` (constructor === Object)\n\nCast property to the given type according to the following description:\n* **to number from**:\n\t* string\t\t\t(\"12.34\": 12.34)\n* **to integer from**:\n\t* number \t\t\t(12.34: 12)\n\t* string\t\t\t(\"12.34\": 12)\n\t* boolean\t\t\t(true: 1, false: 0)\n* **to string from**:\n\t* boolean\t\t\t\t(true: \"true\")\n\t* number\t\t\t\t(12.34: \"12.34\")\n\t* integer\t\t\t\t(12: \"12\")\n\t* date\t\t\t\t\t([object Date]: \"Mon Feb 25 2013 12:03:25 GMT+0100 (CET)\")\n\t* array\t\t\t\t\t([12, 23, 44]: '12,34,45')\n* **to date from**:\n\t* number\t\t\t\t(1361790386000 -> Mon Feb 25 2013 12:06:26 GMT+0100 (CET))\n\t* string\t\t\t\t(\"2013-02-25T11:06:26.704Z\" -> Mon Feb 25 2013 12:06:26 GMT+0100 (CET))\n\t\t\t\t\t\t\t\t\t(\"Mon Feb 25 2013 12:06:26 GMT+0100 (CET)\" -> Mon Feb 25 2013 12:06:26 GMT+0100 (CET))\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\titems: { type: 'string' }\n\t};\n\n\tvar c = [12.23, -34, true, false, 'true', 'false', [123, 234, 345]];\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: ['12.23', '-34', 'true', 'false', 'true', 'false', '123,234,345']\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_def\" />\n### def\n* **type**: any.\n* **usable on**: any.\n\nDefine default value if property does not exist, or if type casting is to fail\nbecause entry type is not valid (cf [type](#s_type)).\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', def: 10 },\n\t\t\tipsum: { type: 'string', def: 'NikitaJS', optional: false },\n\t\t\tdolor: { type: 'string' }\n\t\t}\n\t};\n\n\tvar c = {\n\t\tlorem: [12, 23],\t// convertion to number is about to fail\n\t\t\t\t\t\t\t\t\t\t\t// (array -> number is not possible)\n\t\t\t\t\t\t\t\t\t\t\t// ipsum is not privided\n\t\tdolor: 'sit amet' // \"dolor\" is already a string\n\t};\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: {\n\t\t\tlorem: 10,\n\t\t\tipsum: 'NikitaJS',\n\t\t\tdolor: 'sit amet'\n\t\t}\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_optional\" />\n### optional\n\n* **type**: boolean.\n* **default**: true.\n* **usable on**: any.\n\nProperty is set to `schema.def` if not provided and if optional is `false`.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', optional: false, def: 12 },\n\t\t\tipsum: { type: 'string', optional: true, def: 23 },\n\t\t\tdolor: { type: 'string', def: 'NikitaJS, def: 34 } // (optional: true)\n\t\t}\n\t};\n\n\tvar c = { };\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: {\n\t\t\tlorem: 12 // Only lorem is set to 12 because it is not optional.\n\t\t}\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_rules\" />\n### rules\n\n* **type**: string, array of string.\n* **usable on**: string.\n* **possible values**:\n\t* `upper`: Every character will be changed to uppercase.\n\t* `lower`: Every character will be changed to lowercase.\n\t* `title`: For each word (/\\S*/g), first letter will be changed to uppercase, and the rest to lowercase.\n\t* `capitalize`: Only the first letter of the string will be changed to uppercase, the rest to lowercase.\n\t* `ucfirst`: Only the first letter of the string will be changed to uppercase, the rest is not modified.\n\t* `trim`: Remove extra spaces.\n\nApply the given rule to a string. If several rules are given (array), then they\nare applied in the same order than in the array.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'string', rules: 'upper' },\n\t\t\tipsum: { type: 'string', rules: [ 'trim', 'title'] }\n\t\t}\n\t};\n\n\tvar c = {\n\t\tlorem: ' tHiS is sParTa! ',\n\t\tipsum: '   tHiS is sParTa!    '\n\t};\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: {\n\t\t\tlorem: ' THIS IS SPARTA! ',\n\t\t\tipsum: 'This Is Sparta!' // has been trimed, then titled\n\t\t}\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_comparators\" />\n### min, max\n\n* **type**: string, number.\n* **usable on**: string, number.\n\nDefine minimum and maximum value for a property. If it's less than minimum,\nthen it's set to minimum. If it's greater than maximum, then it's set to\nmaximum.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\titems: { type: 'number', min: 10, max: 20 }\n\t};\n\n\tvar c = [5, 10, 15, 20, 25];\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: [10, 10, 15, 20, 20]\n\t\tc[0] (5) was less than min (10), so it's been set to 10.\n\t\tc[4] (25) was greater than max (20), so it's been set to 20.\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_length\" />\n### minLength, maxLength\n\n* **type**: integer.\n* **usable on**: string.\n\nAdjust string length to the given number.\n\n__TODO:__ We must be able to choose which character we want to fill the string with.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\titems: { type: 'string', minLength: 8, maxLength: 11 }\n\t};\n\n\tvar c = ['short', 'mediumSize', 'tooLongForThisSchema'];\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: ['short---', 'mediumSize', 'tooLongForT']\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_exec\" />\n### exec\n\n* **type**: function, array of functions.\n* **usable on**: any.\n\nCustom checker =). \"exec\" functions take two three parameter\n(schema, post [, callback]), and must return the new value. To report an\nsanitization, use `this.report([message])`. Very useful to make some custom\nsanitization.\n\n__NB:__ If you don't want to return a differant value, simply return `post`,\ndo not return nothing (if you do so, the new value will be `undefined`).\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string',\n\t\t\texec: function (schema, post) {\n\t\t\t\tif (typeof post === 'string' && !/^nikita$/i.test(post)) {\n\t\t\t\t\tthis.report();\n\t\t\t\t\treturn '_INVALID_';\n\t\t\t\t}\n\t\t\t\treturn post;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar c = [ 'Nikita', 'lol', 'NIKITA', 'thisIsGonnaBeSanitized!' ];\n\n\tvar r = SchemaInspector.sanitize(schema, c);\n\t/*\n\t\tc: [ 'Nikita', '_INVALID_', 'NIKITA', '_INVALID_' ]\n\t*/\n```\n\n---------------------------------------\n\n<a name=\"s_properties\" />\n### properties\n\n* **type**: object.\n* **usable on**: object.\n\nWork the same way as [validation \"properties\"](#v_properties).\n\n---------------------------------------\n\n<a name=\"s_items\" />\n### items\n\n* **type**: object, array of object.\n* **usable on**: array.\n\nWork the same way as [validation \"items\"](#v_items).\n\n## Custom fields\n\n<a name=\"cf_punctual\" />\n### punctual use\n\nWhen you need to use the same function in `exec` field several time, instead of\nsaving the function and declaring `exec` several times, just use custom field.\nFirst you have to provide a hash containing a function for each custom field you\nwant to inject. Then you can call them in your schema with $\"your field name\".\nFor example if you\nprovide a custom field called \"superiorMod\", you can access itwith name\n\"$superiorMod\".\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', $divisibleBy: 5 },\n\t\t\tipsum: { type: 'number', $divisibleBy: 3 }\n\t\t}\n\t};\n\n\tvar custom = {\n\t\tdivisibleBy: function (schema, candidate) {\n\t\t\tvar dvb = schema.$divisibleBy;16\n\t\t\tif (cndidate % dvb !== 0) {\n\t\t\t\tthis.report('must be divisible by ' + dvb);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar c = {\n\t\tlorem: 10,\n\t\tipsum: 8\n\t};\n\tsi.validate(schema, candidate, custom); // Invalid: \"@.ipsum must be divisible by 3\"\n```\n\n---------------------------------------\n\n<a name=\"cf_extension\" />\n### extension\n\nSometime you want to use a custom field everywhere in your programme, so you may\nextend Schema-Inspector to do so. Just call the method\n_si.Validation.extend(customFieldObject)_ or\n_si.Sanitization.extend(customFieldObject)_. If you want to reset, simply call\n_si.Validation.reset()_ or _si.Sanitization.reset()_. You also can remove a\nspecific field by calling _si.Validation.remove(field)_ or\n_si.Sanitization.remove(field)_.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar custom = {\n\t\tdivisibleBy: function (schema, candidate) {\n\t\t\tvar dvb = schema.$divisibleBy;16\n\t\t\tif (cndidate % dvb !== 0) {\n\t\t\t\tthis.report('must be divisible by ' + dvb);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', $divisibleBy: 5 },\n\t\t\tipsum: { type: 'number', $divisibleBy: 3 }\n\t\t}\n\t};\n\n\tsi.Validation.extend(custom);\n\n\tvar candidate = {\n\t\tlorem: 10,\n\t\tipsum: 8\n\t};\n\n\tsi.validate(schema, candidate);\n\t/*\n\t\tAs you can see, no more object than schema and candidate has been provided.\n\t\tTherefore we can use `$divisibleBy` everywhere in all schemas, for each\n\t\tsi.validate() call.\n\t*/\n```\n\n<a name=\"cf_context\" />\n### Context\n\nEvery function you declare as a custom parameter, or with `exec` field will be\ncalled with a context. This context allow you to access properties, like\n`this.report()` function, but also `this.origin`, which is equal to the object\nsent to `si.validate()` or `si.sanitize()`.\n\n__Example__\n\n```javascript\n\t// ...\n\tvar schema = { ... };\n\tvar custom = {\n\t\tdivisibleBy: function (schema, candidate) {\n\t\t\t// this.origin === [12, 23, 34, 45]\n\t\t\t// ...\n\t\t}\n\t};\n\tvar candidate = [12, 23, 34, 45];\n\tvar r = si.validate(schema, candidate, custom);\n\t// ...\n\n```\n\n## Asynchronous call\n\n<a name=\"a_howTo\" />\n### How to\n\nAll the example above used synchronous call (the simplest). But sometime you\nwant to call validation or sanitization asynchronously, in particular with\n`exec` and custom fields. It's pretty simple: To do so, just send a callback\nas extra parameter. It takes 2 parameters: error and result. Actually\nSchema-Inspector should send back no error as it should not throw any if called\nsynchronously. But if you want to send back and error in your custom function,\ninspection will be interrupted, and you will be able to retrieve it in your\ncallback.\n\nYou also have to declare a callback in your `exec` or custom function to make\nSchema-Inspector call it asynchronously, else it will be call synchronously.\nThat means you may use `exec` synchronous function normally even during\nand asynchronous call.\n\n__Example__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = { ...\t};\n\tvar candidate = { ... };\n\n\tsi.validate(schema, candidate, function (err, result) {\n\t\tconsole.log(result.format());\n\t});\n```\n\n__Example with custom field__\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = { ...\t};\n\tvar candidate = { ... };\n\tvar custom = { ... };\n\n\tsi.validate(schema, candidate, custom, function (err, result) {\n\t\tconsole.log(result.format());\n\t});\n```\n\nHere a full example where you may have to use it:\n\n```javascript\n\tvar si = require('schema-inspector');\n\n\tvar schema = {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tlorem: { type: 'number', $divisibleBy: 4 },\n\t\t\tipsum: { type: 'number', $divisibleBy: 5 },\n\t\t\tdolor: { type: 'number', $divisibleBy: 0, optional: true }\n\t\t}\n\t};\n\n\tvar custom = {\n\t\tdivisibleBy: function (schema, candidate, callback) { // Third parameter is declared:\n\t\t\t// Schema-Inspector will wait this function to call this `callback` to keep running.\n\t\t\tvar dvb = schema.$divisibleBy;\n\t\t\tif (typeof dvb !== 'number' || typeof candidate !== 'number') {\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t\tvar self = this;\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tif (dvb === 0) {\n\t\t\t\t\treturn callback(new Error('Schema error: Divisor must not equal 0'));\n\t\t\t\t}\n\t\t\t\tvar r = candidate / dvb;\n\t\t\t\tif ((r | 0) !== r)  {\n\t\t\t\t\tself.report('should be divisible by ' + dvb);\n\t\t\t\t}\n\t\t\t\tcallback();\n\t\t\t});\n\t\t}\n\t};\n\n\tvar candidate = {\n\t\tlorem: 12,\n\t\tipsum: 25\n\t};\n\n\tsi.validate(schema, candidate, custom, function (err, result) {\n\t\tconsole.log(result.format());\n\t});\n```\n",
  "readmeFilename": "README.md",
  "description": "Schema-Inspector is powerful tools to validation or sanitize javascript object. It is disigned to work both client-side and server-side. Although originally designed for use with [node.js](http://nodejs.org), it can also be used directly in the browser."
}
